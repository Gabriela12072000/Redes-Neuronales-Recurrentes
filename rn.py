# -*- coding: utf-8 -*-
"""RN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TTAENnGaqtzelMrvYsBH7yI9LOE1LQHs
"""

import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt

# Descargar y cargar datos desde una fuente en línea
dataset_url = "https://raw.githubusercontent.com/jbrownlee/Datasets/master/airline-passengers.csv"
df = pd.read_csv(dataset_url)

def preprocess_data(df):
    # Convertir la columna de pasajeros en un array numpy
    data = df['Passengers'].values.astype(float)
    data = data.reshape(-1, 1)

    # Normalización de datos
    scaler = MinMaxScaler(feature_range=(0, 1))
    data_scaled = scaler.fit_transform(data)

    # Crear secuencias de entrenamiento
    sequence_length = 10  # Número de pasos de tiempo considerados
    X, y = [], []
    for i in range(len(data_scaled) - sequence_length):
        X.append(data_scaled[i:i+sequence_length])
        y.append(data_scaled[i+sequence_length])

    return np.array(X), np.array(y), scaler

X, y, scaler = preprocess_data(df)

# Separar datos de entrenamiento y prueba
train_size = int(len(X) * 0.8)
X_train, X_test = X[:train_size], X[train_size:]
y_train, y_test = y[:train_size], y[train_size:]

# Construcción del modelo LSTM
model = Sequential([
    LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], 1)),
    Dropout(0.2),
    LSTM(50, return_sequences=False),
    Dropout(0.2),
    Dense(1)
])

# Justificación del optimizador
# Adam es elegido porque maneja bien el gradiente en secuencias largas
optimizer = tf.keras.optimizers.Adam(learning_rate=0.001)

# Compilar el modelo
model.compile(optimizer=optimizer, loss='mean_squared_error')

# Entrenar el modelo
history = model.fit(X_train, y_train, epochs=50, batch_size=16, validation_data=(X_test, y_test))

# Predicción y desnormalización
y_pred = model.predict(X_test)
y_pred = scaler.inverse_transform(y_pred)
y_test = scaler.inverse_transform(y_test.reshape(-1, 1))

# Visualización de resultados
plt.figure(figsize=(10,5))
plt.plot(y_test, label='Real')
plt.plot(y_pred, label='Predicción')
plt.legend()
plt.show()